<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSE Streaming Test</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        input, button { padding: 10px; margin: 5px; }
        #response { border: 1px solid #ccc; padding: 10px; min-height: 200px; white-space: pre-wrap; }
        .loading { color: green; }
        .error { color: red; }
    </style>
</head>
<body>
    <h1>SSE Streaming API Test</h1>
    <div>
        <label for="message">Message:</label><br>
        <input type="text" id="message" placeholder="Enter your test message" style="width: 100%;">
    </div>
    <button onclick="sendMessage()">Send</button>
    <div id="status"></div>
    <div id="response"></div>

    <script>
        async function sendMessage() {
            const hardcodedToken = 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0ZDU2NDkzYy01NDY5LTQxN2QtODljMy0zZjg4MmMyNGQ0NDAiLCJleHAiOjE3NTc5NDY1MDh9.E2kEcA09lUyWNB1SdBUmQPrFkACTOgu1GQPlMYeSZo8';
            const message = document.getElementById('message').value.trim();
            const statusEl = document.getElementById('status');
            const responseEl = document.getElementById('response');

            if (!message) {
                statusEl.innerHTML = '<span class="error">Please provide message.</span>';
                return;
            }

            statusEl.innerHTML = '<span class="loading">Sending...</span>';
            responseEl.innerHTML = '';

            try {
                const formData = new FormData();
                formData.append('message', message);
                console.log('FormData contents:', message);  // Debug log

                const response = await fetch('http://localhost:8000/api/v1/chat/stream', {
                    method: 'POST',
                    headers: {
                        'Authorization': hardcodedToken
                    },
                    body: formData
                });

                console.log('Response status:', response.status);  // Debug log

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    let lines = buffer.split('\n');
                    buffer = lines.pop() || '';  // Keep incomplete line

                    for (let line of lines) {
                        if (line.startsWith('data: ')) {
                            const dataStr = line.slice(6);
                            if (dataStr === '[DONE]') {
                                statusEl.innerHTML = '<span class="loading">Complete!</span>';
                                break;
                            }

                            try {
                                const event = JSON.parse(dataStr);
                                console.log('Parsed event:', event);  // Debug log
                                appendEvent(event);
                            } catch (e) {
                                console.error('Parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }

                // Handle remaining buffer
                if (buffer.startsWith('data: ')) {
                    const dataStr = buffer.slice(6);
                    if (dataStr !== '[DONE]') {
                        try {
                            const event = JSON.parse(dataStr);
                            appendEvent(event);
                        } catch (e) {
                            console.error('Parse error:', e);
                        }
                    }
                }

            } catch (error) {
                statusEl.innerHTML = `<span class="error">Error: ${error.message}</span>`;
                console.error(error);
            }
        }

        function appendEvent(event) {
            const responseEl = document.getElementById('response');
            const statusEl = document.getElementById('status');

            if (event.type === 'content') {
                responseEl.innerHTML += event.delta;
            } else if (event.type === 'tool_start') {
                responseEl.innerHTML += `\n\n--- Tool started: ${event.tool} ---\n`;
            } else if (event.type === 'tool_end') {
                responseEl.innerHTML += `\nTool output: ${event.output}\n`;
            } else if (event.type === 'done') {
                responseEl.innerHTML += `\n\n--- Final ---\nConversation ID: ${event.conversation_id}\nMessage ID: ${event.message_id}\nTool Used: ${event.tool_used || 'None'}\nFiles Processed: ${event.files_processed || 0}`;
                if (event.sources && event.sources.length > 0) {
                    responseEl.innerHTML += `\nSources:\n`;
                    event.sources.forEach(source => {
                        responseEl.innerHTML += `- ${source.title} (${source.subreddit})\n`;
                    });
                }
            } else if (event.type === 'error') {
                responseEl.innerHTML += `\n\nError: ${event.content}`;
                statusEl.innerHTML = '<span class="error">Stream error occurred.</span>';
            }

            responseEl.scrollTop = responseEl.scrollHeight;
        }
    </script>
</body>
</html>
